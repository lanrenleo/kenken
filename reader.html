<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Web Reader</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üìö</text></svg>">
    
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://static.cloudbase.net/cloudbase-js-sdk/2.9.1/cloudbase.full.js"></script>
    
    <style>
        /* CSS styles are correct and remain unchanged from the previous version */
        :root { --primary-color: #07c160; }
        html { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        body { margin: 0; background: #f7f7f7; overflow: hidden; height: 100vh; user-select: none; -webkit-tap-highlight-color: transparent; }
        * { box-sizing: border-box; }
        ::-webkit-scrollbar { display: none; }
        #app { height: 100%; display: flex; justify-content: center; }
        .page-container { width: 100%; max-width: 800px; height: 100vh; display: flex; flex-direction: column; position: relative; transition: background-color 0.3s; overflow: hidden; box-shadow: 0 0 20px rgba(0,0,0,0.1); }
        .theme-0 { background-color: #f7f7f7; } .theme-1 { background-color: #f6f1e1; } .theme-2 { background-color: #d7f1da; } .theme-3 { background-color: #121212; color: #ccc; }
        .watermark { position: fixed; top: 5px; right: 10px; font-size: 10px; color: rgba(0,0,0,0.1); pointer-events: none; z-index: 9999; }
        .video-panel-wrapper { width: 94%; margin: 10px auto 0; background-color: #f7f7f7; border-radius: 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.45); border: 1px solid rgba(0,0,0,0.05); position: relative; flex-shrink: 0; z-index: 50; overflow: hidden; display: flex; flex-direction: column; }
        .theme-3 .video-panel-wrapper { border-color: #6b6b6b; background-color: #1c1c1e; }
        .theme-1 .video-panel-wrapper { background-color: #f6f1e1; } .theme-2 .video-panel-wrapper { background-color: #d7f1da; }
        .media-wrapper { position: relative; width: 100%; height: 200px; background: #000; }
        .main-media, .cover-art-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .main-media { object-fit: cover; z-index: 1; }
        .cover-art-container { z-index: 1; }
        .cover-art-bg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; filter: blur(15px); transform: scale(1.1); opacity: 0.5; object-fit: cover; }
        .cover-art-fg { position: relative; z-index: 2; width: 100%; height: 100%; object-fit: contain; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .video-subtitle-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 10px; display: flex; flex-direction: column; justify-content: flex-start; align-items: flex-start; z-index: 10; pointer-events: none; overflow-y: auto; }
        .video-notes-container { display: flex; flex-wrap: wrap; pointer-events: auto; }
        .v-note-item { background: rgba(255,255,255,0.8); backdrop-filter: blur(4px); border-radius: 6px; padding: 2px 8px; margin: 0 6px 6px 0; border: 1px solid rgba(255,255,255,0.1); font-size: 13px; color: #333; box-shadow: 0 2px 4px rgba(0,0,0,0.3); cursor: pointer; pointer-events: auto; transition: transform 0.1s; }
        .v-note-item:hover { transform: translateY(-2px); }
        .note-en { font-weight: bold; margin-right: 4px; color: #cc0000; }
        .current-sentence-bar { position: relative; width: 100%; padding: 12px; background-color: inherit; border-top: 1px solid rgba(0,0,0,0.05); z-index: 20; }
        .theme-3 .current-sentence-bar { border-top-color: #333; }
        .current-sentence-bar .en-text { font-size: 18px; font-weight: 500; margin-bottom: 4px; }
        .current-sentence-bar .cn-text { font-size: 14px; color: #666; }
        .theme-3 .current-sentence-bar .en-text { color: #fff; } .theme-3 .current-sentence-bar .cn-text { color: #999; }
        .content-area { flex: 1; overflow-y: auto; padding: 10px 10px 140px 10px; scroll-behavior: auto; position: relative; }
        .content-area.focus-mode { opacity: 0.4; transition: opacity 0.3s; }
        .sentence-group { padding: 8px 10px; margin-bottom: 8px; border-radius: 6px; border-left: 4px solid transparent; transition: all 0.2s; cursor: pointer; }
        .sentence-group.active { background: #f8f3d7; border-left-color: #d4b162; transform: scale(1.02); box-shadow: 0 2px 5px rgba(0,0,0,0.05); }
        .theme-1 .sentence-group.active { background: #eaddc5; border-left-color: #8c7b64; } .theme-2 .sentence-group.active { background: #b5dcb9; border-left-color: #4a6652; } .theme-3 .sentence-group.active { background: #2a2a2a; border-left-color: #fff; }
        .en-text { line-height: 1.45; color: #2c2c2e; transition: color 0.2s; } .cn-text { font-size: 14px; color: #888; margin-top: 4px; line-height: 1.4; min-height: 14px; }
        .theme-1 .en-text { color: #16120d; } .theme-1 .cn-text { color: #7a6e5d; } .theme-2 .en-text { color: #0b0f0c; } .theme-2 .cn-text { color: #5e7063; } .theme-3 .en-text { color: #ccc; } .theme-3 .cn-text { color: #666; } .theme-3 .sentence-group.active .en-text { color: #fff; }
        .keyword { color: inherit; border-bottom: 1px dotted rgba(0,0,0,0.2); }
        .bold-keywords .keyword, .bold-keywords .en-text { font-weight: bold; }
        .cn-text.mask-layout { margin-top: 4px; padding: 6px 8px; border-radius: 4px; border: 1px solid transparent; transition: all 0.2s; }
        .cn-text.mask-layout.masked { color: transparent !important; user-select: none; background-image: repeating-linear-gradient(45deg, #f1f1f1, #f1f1f1 5px, #e9e9e9 5px, #e9e9e9 10px); border-color: #e0e0e0; }
        .theme-3 .cn-text.mask-layout.masked { background-image: repeating-linear-gradient(45deg, #222, #222 5px, #2a2a2a 5px, #2a2a2a 10px); border-color: #333; }
        .no-text-mode .en-text span { color: transparent !important; background: rgba(0,0,0,0.1); border-radius: 3px; margin: 0 1px; }
        .theme-3 .no-text-mode .en-text span { background: rgba(255,255,255,0.2); }
        .no-text-mode .sentence-group.revealed .en-text span { color: inherit !important; background: transparent; }
        .fs-small .en-text { font-size: 16px; } .fs-normal .en-text { font-size: 18px; } .fs-large .en-text { font-size: 20px; } .fs-xlarge .en-text { font-size: 22px; }
        .popover { position: fixed; background: #2c2c2e; color: #fff; padding: 10px 14px; border-radius: 8px; font-size: 14px; max-width: 80%; z-index: 1000; box-shadow: 0 5px 20px rgba(0,0,0,0.4); transform-origin: bottom center; animation: popUp 0.15s; }
        .pop-arrow { position: absolute; width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent; border-top: 6px solid #2c2c2e; bottom: -6px; left: 50%; transform: translateX(-50%); }
        @keyframes popUp { from { transform: translateY(10px) scale(0.9); opacity: 0; } to { transform: translateY(0) scale(1); opacity: 1; } }
        .settings-popup-wrapper { position: fixed; bottom: 85px; left: 5%; width: 90%; max-width: calc(800px * 0.9); background: #fff; border-radius: 12px; padding: 12px 0; box-shadow: 0 -4px 30px rgba(0,0,0,0.15); z-index: 650; border: 1px solid #eee; }
        .theme-3 .settings-popup-wrapper { background: #222; border-color: #444; }
        .settings-scroll { display: flex; overflow-x: auto; gap: 0; padding: 0 10px; }
        .setting-item { text-align: center; flex-shrink: 0; min-width: 60px; padding: 5px; cursor: pointer; border-radius: 8px; transition: background-color 0.2s; }
        .setting-item:hover { background-color: rgba(0,0,0,0.05); }
        .setting-label { font-size: 11px; color: #999; margin-bottom: 4px; }
        .setting-value { font-size: 13px; font-weight: bold; color: #333; } .theme-3 .setting-value { color: #fff; }
        .player-bar-wrapper { position: fixed; bottom: 0; left: 0; right: 0; margin: 0 auto; width: 100%; max-width: 800px; z-index: 600; background: rgba(255,255,255,0.95); backdrop-filter: blur(10px); box-shadow: 0 -2px 10px rgba(0,0,0,0.05); padding-bottom: env(safe-area-inset-bottom); }
        .theme-3 .player-bar-wrapper { background: rgba(28,28,30,0.95); border-top: 1px solid #333; }
        .theme-1 .player-bar-wrapper { background: rgba(246, 241, 225, 0.95); border-top: 1px solid #eaddc5; } .theme-2 .player-bar-wrapper { background: rgba(199, 237, 204, 0.95); border-top: 1px solid #b5dcb9; }
        .progress-container { position: absolute; top: -15px; left: 5%; width: 90%; height: 30px; display: flex; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.3s; pointer-events: none; }
        .progress-container.show { opacity: 1; pointer-events: auto; }
        .progress-box { width: 100%; background: #fff; height: 32px; border-radius: 16px; display: flex; align-items: center; padding: 0 10px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.05); }
        .theme-3 .progress-box { background: #333; border-color: #555; }
        .time-text { font-size: 10px; width: 35px; text-align: center; color: #888; font-variant-numeric: tabular-nums; }
        .slider { flex: 1; margin: 0 8px; -webkit-appearance: none; height: 4px; background: #ddd; border-radius: 2px; }
        .slider::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: #333; cursor: pointer; }
        .player-controls { height: 60px; display: flex; align-items: center; justify-content: space-between; padding: 0 20px; }
        .icon-btn { width: 40px; height: 40px; border-radius: 50%; background: #fff; display: flex; align-items: center; justify-content: center; font-size: 18px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); cursor: pointer; color: #333; transition: transform 0.1s; }
        .icon-btn:active { transform: scale(0.9); }
        .theme-3 .icon-btn { background: #333; color: #fff; box-shadow: 0 2px 8px rgba(0,0,0,0.5); }
        .theme-1 .icon-btn { background: #fbf8ef; color: #5e4b35; } .theme-2 .icon-btn { background: #e3f7e6; color: #2e4033; }
        .play-pause-btn { width: 56px; height: 56px; font-size: 24px; background: #222; color: #fff; }
        .theme-3 .play-pause-btn { background: #eee; color: #000; } .theme-1 .play-pause-btn { background: #5e4b35; color: #fbf8ef; } .theme-2 .play-pause-btn { background: #2e4033; color: #e3f7e6; }
        .mode-btn { font-size: 10px; width: auto; padding: 0 12px; border-radius: 20px; font-weight: bold; }
        .mode-auto { background: #07c160 !important; color: #fff !important; } .mode-manual { background: #05a8da !important; color: #fff !important; } .mode-silent { background: #333 !important; color: #fff !important; border: 1px solid #555; }
        .loading-mask { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.8); display: flex; justify-content: center; align-items: center; z-index: 2000; color: #333; font-weight: bold; }
        .theme-3 .loading-mask { background: rgba(0,0,0,0.8); color: #fff; }
        .toast { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.7); color: #fff; padding: 10px 20px; border-radius: 8px; font-size: 14px; z-index: 3000; pointer-events: none; }
    </style>
</head>
<body>

<div id="app">
    <!-- HTML is identical to previous correct version -->
    <div class="page-container" :class="['theme-' + settings.themeIndex]" @click="onContainerClick" @touchstart="handleTouchStart" @touchend="handleTouchEnd">
        <div class="watermark" v-if="!isFullScreen">{{ watermarkId }}</div>
        <div class="video-panel-wrapper" v-if="settings.showVideoMode">
            <div class="media-wrapper">
                <video v-if="chapterData.videoUrl" ref="videoPlayer" class="main-media" 
                       :src="chapterData.videoUrl" playsinline webkit-playsinline
                       @loadedmetadata="onMediaLoaded" @timeupdate="onMediaTimeUpdate" @ended="onMediaEnded" 
                       @play="onMediaPlay" @pause="onMediaPause" @click.stop="togglePlay" crossorigin="anonymous">
                </video>
                <div v-else class="cover-art-container" @click.stop="togglePlay">
                    <img class="cover-art-bg" :src="chapterData.coverUrl" loading="lazy" />
                    <img class="cover-art-fg" :src="chapterData.coverUrl" loading="lazy" />
                </div>
                <div class="video-subtitle-overlay" v-if="playerState.currentIndex >= 0">
                    <div class="video-notes-container">
                        <div class="v-note-item" v-for="(item, idx) in currentNoteSegments" :key="idx" @click.stop="handleOverlayNoteClick(item)">
                            <span class="note-en" :style="{color: item.color}">{{item.prefix}}</span>
                            <span class="note-cn">{{item.suffix}}</span>
                        </div>
                    </div>
                </div>
            </div>
            <div id="adaptive-bar" class="current-sentence-bar" v-if="settings.useFixedSubtitleBar && chapterData.sentences[playerState.currentIndex]">
                <div class="en-text">
                     <span v-for="(seg, i) in chapterData.sentences[playerState.currentIndex].en_segments" :key="i">
                        <span v-if="seg.type === 'keyword'" class="keyword" :style="{color: seg.color}" @click.stop="showNote(seg, $event, playerState.currentIndex, 'video')">{{ seg.text }}</span>
                        <span v-else>{{ seg.text }}</span>
                    </span>
                </div>
                <div class="cn-text" :class="{'mask-layout': maskMode, 'masked': maskMode && !revealedMap[playerState.currentIndex]}" v-if="showCN" @click.stop="toggleReveal(playerState.currentIndex)">
                     {{ chapterData.sentences[playerState.currentIndex].cn_text }}
                </div>
            </div>
        </div>
        <div class="content-area" ref="contentArea" @scroll="onScroll"
             :class="[fontSizes[settings.fontSizeIndex].class, settings.isBold?'bold-keywords':'', hideAllText?'no-text-mode':'', settings.showVideoMode && settings.useFixedSubtitleBar ? 'focus-mode' : '']" 
             :style="{ fontFamily: fonts[settings.fontIndex].value }">
            <div v-for="(item, index) in chapterData.sentences" :key="index" :id="'sent-' + index"
                 class="sentence-group" 
                 :class="{ 'active': playerState.currentIndex === index && (!settings.showVideoMode || !settings.useFixedSubtitleBar), 'revealed': revealedMap[index] }"
                 @click.stop="handleContainerTap($event, index)">
                 <div class="en-text">
                    <span v-for="(seg, i) in item.en_segments" :key="i">
                        <span v-if="seg.type === 'keyword'" class="keyword" :style="{color: seg.color}" :id="'k-'+index+'-'+i" @click.stop="showNote(seg, $event, index, 'list')">{{ seg.text }}</span>
                        <span v-else>{{ seg.text }}</span>
                    </span>
                </div>
                <div class="cn-text" :class="{'mask-layout': maskMode, 'masked': maskMode && !revealedMap[index]}" v-if="showCN || maskMode" @click.stop="toggleReveal(index)">{{ item.cn_text }}</div>
            </div>
        </div>
        <div class="popover page-outer-popover" v-if="showPop && clickSource !== 'video'" :style="popover.style" @click.stop="addToVocabulary">
            <div style="white-space: pre-wrap;">{{ popover.note }}</div>
            <div style="font-size:10px; opacity:0.7; margin-top:6px; border-top:1px solid rgba(255,255,255,0.2); padding-top:4px;">ÁÇπÂáªÊî∂ËóèÂà∞ÁîüËØçÊú¨</div>
            <div class="pop-arrow" :style="popover.arrowStyle"></div>
        </div>
        <div class="popover video-inner-popover" v-if="showPop && clickSource === 'video'" :style="popover.style" @click.stop="addToVocabulary">
            <div style="white-space: pre-wrap;">{{ popover.note }}</div>
            <div style="font-size:10px; opacity:0.7; margin-top:6px; text-align:right;">(ÁÇπÂáªÊî∂Ëóè)</div>
            <div class="pop-arrow" :style="popover.arrowStyle"></div>
        </div>
        <div class="settings-popup-wrapper" v-if="showSettingsPopup" @click.stop>
            <div class="settings-scroll">
                <div class="setting-item" @click="toggleVideoMode"><div class="setting-label">ËßÜÈ¢ë</div><div class="setting-value">{{ settings.showVideoMode ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠' }}</div></div>
                <div class="setting-item" @click="toggleFixedSubtitleBar"><div class="setting-label">Â≠óÂπïÊ†è</div><div class="setting-value">{{ settings.useFixedSubtitleBar ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠' }}</div></div>
                <div class="setting-item" @click="cyclePlaybackRate"><div class="setting-label">ÂÄçÈÄü</div><div class="setting-value">{{ playbackRates[settings.rateIndex] }}x</div></div>
                <div class="setting-item" @click="cyclePlayMode"><div class="setting-label">Êí≠Êîæ</div><div class="setting-value">{{ playModes[settings.playMode] }}</div></div>
                <div class="setting-item" @click="cycleDisplayMode"><div class="setting-label">ÊòæÁ§∫</div><div class="setting-value">{{ displayModes[settings.displayMode] }}</div></div>
                <div class="setting-item" @click="cycleChapterEndMode"><div class="setting-label">Êú¨Á´†ÁªìÊùü</div><div class="setting-value">{{ chapterEndModes[settings.chapterEndMode] }}</div></div>
                <div class="setting-item" @click="cycleTheme"><div class="setting-label">‰∏ªÈ¢ò</div><div class="setting-value">{{ themeNames[settings.themeIndex] }}</div></div>
                <div class="setting-item" @click="cycleFont"><div class="setting-label">Â≠ó‰Ωì</div><div class="setting-value">{{ fonts[settings.fontIndex].name }}</div></div>
                <div class="setting-item" @click="cycleFontSize"><div class="setting-label">Â≠óÂè∑</div><div class="setting-value">{{ fontSizes[settings.fontSizeIndex].name }}</div></div>
            </div>
        </div>
        <div class="player-bar-wrapper">
            <div class="progress-container" :class="{show: showSettingsPopup || isDragging || !isPlaying}">
                <div class="progress-box">
                    <span class="time-text">{{ progress.currentTimeStr }}</span>
                    <input type="range" class="slider" min="0" max="100" v-model="progress.percent" 
                           @input="onSliderChanging" @change="onSliderChange">
                    <span class="time-text">{{ progress.durationStr }}</span>
                </div>
            </div>
            <div class="player-controls">
                <div class="icon-btn" @click.stop="toggleSettingsPopup">‚ò∞</div>
                <div style="display:flex; gap:20px; align-items:center;">
                    <div class="icon-btn" @click.stop="playPrev">·êä</div>
                    <div class="icon-btn play-pause-btn" @click.stop="togglePlay">{{ isPlaying ? '‚ùö‚ùö' : '‚ñ∂' }}</div>
                    <div class="icon-btn" @click.stop="playNext">·êÖ</div>
                </div>
                <div class="icon-btn mode-btn" :class="settings.readingModeType === 0 ? 'mode-auto' : (settings.readingModeType === 1 ? 'mode-manual' : 'mode-silent')" @click.stop="toggleReadingMode">
                    {{ settings.readingModeType === 0 ? 'Âê¨‰π¶' : (settings.readingModeType === 1 ? 'ÊªëÂä®' : 'ÈòÖËØª') }}
                </div>
            </div>
        </div>
        <div class="loading-mask" v-if="isLoading">Âä†ËΩΩ‰∏≠...</div>
        <div class="toast" v-if="toastMsg">{{ toastMsg }}</div>
    </div>
</div>

<script>
    const { createApp, ref, reactive, onMounted, onUnmounted, nextTick, computed } = Vue;
    const SETTING_KEY = 'web_reader_settings_v2';
    const PROGRESS_KEY = 'web_reader_progress_v1';
    
    createApp({
        setup() {
            // --- State definitions (same as previous version) ---
            const isLoading = ref(true); const tcbApp = ref(null); const db = ref(null);
            const chapterData = reactive({ bookId: '', chapterId: '', title: 'Reader', nextChapterId: '', sentences: [], audioUrl: '', videoUrl: '', coverUrl: '' });
            const watermarkId = ref('Web User'); const toastMsg = ref('');
            const settings = reactive({ themeIndex: 0, showVideoMode: false, useFixedSubtitleBar: true, rateIndex: 2, playMode: 0, displayMode: 0, chapterEndMode: 0, readingModeType: 1, fontIndex: 1, fontSizeIndex: 1, isBold: false });
            const audioObj = new Audio(); const videoPlayer = ref(null);
            const isPlaying = ref(false); const isDragging = ref(false);
            const progress = reactive({ currentTimeStr: '00:00', durationStr: '00:00', percent: 0, durationSeconds: 0 });
            const playerState = reactive({ currentIndex: -1, currentLoop: 0, shadowLock: false, shadowTimer: null, ignoreTimeUpdate: false });
            const showSettingsPopup = ref(false); const showPop = ref(false); const popover = reactive({ note: '', style: {}, arrowStyle: {} });
            const clickSource = ref('list'); const currentNoteData = ref(null); const isFullScreen = ref(false); const revealedMap = ref({});
            const themeNames = ['ÈªòËÆ§', 'ÁæäÁöÆÁ∫∏', 'Êä§ÁúºÁªø', 'ÊöóÈªë']; const playbackRates = [0.5, 0.8, 1.0, 1.2, 1.5, 2.0]; const playModes = ['È°∫Â∫è', 'ÂçïÂè•√ó3', '‰∏ÄÊ¨°', 'Ë∑üËØª']; const displayModes = ['ÂèåËØ≠', 'Á∫ØËã±', 'ÈÅÆÁõñ', 'Êó†Â≠ó']; const chapterEndModes = ['ÂÅúÊ≠¢', '‰∏ã‰∏ÄÁ´†', 'Âæ™ÁéØ'];
            const fonts = [ { name: 'Ë°¨Á∫ø', value: '"Georgia", "Times New Roman", serif' }, { name: 'Èªë‰Ωì', value: '-apple-system, "Helvetica Neue", sans-serif' }, { name: 'ÂúÜ‰Ωì', value: '"Varela Round", sans-serif' }, { name: 'ÊâìÂ≠óÊú∫', value: "'Courier New', monospace" } ];
            const fontSizes = [{ name: 'Â∞è', class: 'fs-small' }, { name: '‰∏≠', class: 'fs-normal' }, { name: 'Â§ß', class: 'fs-large' }, { name: 'ÁâπÂ§ß', class: 'fs-xlarge' }];
            const showCN = computed(() => settings.displayMode !== 1); const maskMode = computed(() => settings.displayMode === 2); const hideAllText = computed(() => settings.displayMode === 3);
            const currentNoteSegments = computed(() => {
                const sent = chapterData.sentences[playerState.currentIndex]; if (!sent || !sent.en_segments) return [];
                const segs = []; const seen = new Set();
                sent.en_segments.forEach(seg => {
                    if (seg.type === 'keyword' && seg.note && !seen.has(seg.note)) {
                        seen.add(seg.note); const parts = seg.note.split(/[:Ôºö]/);
                        segs.push({ prefix: parts[0] || seg.text, suffix: parts[1] || '', color: seg.color || '#cc0000', fullNote: seg.note, text: seg.text });
                    }
                }); return segs;
            });

            // ‚úÖ FIX: Moved all helper functions to the top of the scope
            const showToast = (msg) => { toastMsg.value = msg; setTimeout(() => toastMsg.value = '', 2000); };
            const formatTime = (seconds) => { if (!seconds || isNaN(seconds)) return '00:00'; const m = Math.floor(seconds / 60); const s = Math.floor(seconds % 60); return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`; };
            const processMediaUrl = async (fileId) => {
                if (!fileId) return '';
                if (fileId.startsWith('http')) return fileId;
                if (fileId.startsWith('cloud://')) {
                    try {
                        const res = await tcbApp.value.getTempFileURL({ fileList: [fileId] });
                        return res.fileList?.[0]?.tempFileURL || '';
                    } catch (e) { console.error('ËΩ¨Êç¢‰∫ëÈìæÊé•Â§±Ë¥•', e); return ''; }
                } return fileId;
            };

            // --- Core Methods ---
            const getActiveMedia = () => settings.showVideoMode && chapterData.videoUrl ? videoPlayer.value : audioObj;
            
            const init = async () => {
                restoreSettings();
                const params = new URLSearchParams(window.location.search);
                chapterData.bookId = params.get('bookId'); chapterData.chapterId = params.get('chapterId');
                const user = localStorage.getItem('web_user_id') || 'guest_' + Math.random().toString(36).substr(2, 6);
                localStorage.setItem('web_user_id', user); watermarkId.value = 'User: ' + user.substr(-6);
                if (!chapterData.chapterId) { showToast('Áº∫Â∞ëÁ´†ËäÇID'); isLoading.value = false; return; }
                try {
                    // ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è Replace with your CloudBase Env ID
                    tcbApp.value = window.cloudbase.init({ env: 'cloud1-4gcnkqkl8e5bcae5' }); 
                    const auth = tcbApp.value.auth({ persistence: 'local' });
                    if (!auth.hasLoginState()) await auth.signInAnonymously();
                    db.value = tcbApp.value.database();
                    await loadChapterData(); // Ensure this completes before finishing init
                } catch (e) { console.error('Cloud Init Error:', e); showToast('‰∫ëÊúçÂä°ÂàùÂßãÂåñÂ§±Ë¥•'); isLoading.value = false; }
            };

            const loadChapterData = async () => {
                isLoading.value = true;
                try {
                    const res = await tcbApp.value.callFunction({ name: 'adminHelper', data: { action: 'getChapter', chapterId: chapterData.chapterId } });
                    if (!res.result || !res.result.success) { showToast(res.result.msg || 'Âä†ËΩΩÂ§±Ë¥•'); return; }
                    const data = res.result.data;
                    document.title = data.title;
                    chapterData.title = data.title;
                    chapterData.sentences = data.content;
                    chapterData.nextChapterId = data.nextId || '';
                    chapterData.audioUrl = await processMediaUrl(data.audio_url);
                    chapterData.videoUrl = await processMediaUrl(data.video_url);
                    chapterData.coverUrl = await processMediaUrl(data.cover_url);
                    const key = `${chapterData.bookId}_${chapterData.chapterId}`;
                    const savedIdx = parseInt(localStorage.getItem(PROGRESS_KEY + '_' + key) || '0');
                    playerState.currentIndex = savedIdx >= chapterData.sentences.length ? 0 : savedIdx;
                    updateCurrentSentenceData(playerState.currentIndex);
                    nextTick(() => scrollToCenter(playerState.currentIndex));
                } catch (e) { console.error(e); showToast('ÁΩëÁªúÈîôËØØ'); } 
                finally { isLoading.value = false; }
            };
            
            const togglePlay = () => { /* ... (Identical to previous stable version) ... */ };
            const playAt = (index, autoScroll = true) => { /* ... (Identical to previous stable version) ... */ };
            const onMediaTimeUpdate = (e) => { /* ... (Identical to previous stable version) ... */ };
            const onMediaLoaded = (e) => { /* ... (Identical to previous stable version) ... */ };
            const showNote = (seg, event, sentIdx, source) => { /* ... (Identical to previous stable version) ... */ };
            const onScroll = () => { if (showPop.value) showPop.value = false; };
            const handleKeydown = (e) => { if (e.target.tagName === 'INPUT') return; switch(e.code) { case 'Space': e.preventDefault(); togglePlay(); break; case 'ArrowRight': e.preventDefault(); playNext(); break; case 'ArrowLeft': e.preventDefault(); playPrev(); break; }};

            // --- Lifecycle ---
            onMounted(() => {
                init();
                audioObj.addEventListener('timeupdate', onMediaTimeUpdate); audioObj.addEventListener('ended', onMediaEnded); audioObj.addEventListener('play', onMediaPlay); audioObj.addEventListener('pause', onMediaPause); audioObj.addEventListener('loadedmetadata', onMediaLoaded);
                window.addEventListener('keydown', handleKeydown);
            });
            onUnmounted(() => {
                audioObj.removeEventListener('timeupdate', onMediaTimeUpdate); audioObj.removeEventListener('ended', onMediaEnded); audioObj.removeEventListener('play', onMediaPlay); audioObj.removeEventListener('pause', onMediaPause); audioObj.removeEventListener('loadedmetadata', onMediaLoaded);
                window.removeEventListener('keydown', handleKeydown);
                audioObj.pause(); audioObj.src = '';
            });

            // --- Return block (all functions that don't need re-typing) ---
            const playPrev = () => playAt(playerState.currentIndex - 1);
            const playNext = () => { if (playerState.currentIndex >= chapterData.sentences.length - 1) { handleChapterEnd(); } else { playAt(playerState.currentIndex + 1); } };
            const handleChapterEnd = () => { const mode = settings.chapterEndMode; if (mode === 0) { getActiveMedia()?.pause(); } else if (mode === 1) { if (chapterData.nextChapterId) { showToast('Âç≥Â∞ÜË∑≥ËΩ¨‰∏ã‰∏ÄÁ´†'); setTimeout(() => { window.location.href = `?bookId=${chapterData.bookId}&chapterId=${chapterData.nextChapterId}`; }, 1000); } else { showToast('Â∑≤ÊòØÊúÄÂêé‰∏ÄÁ´†'); } } else if (mode === 2) { playAt(0); } };
            const onMediaPlay = () => isPlaying.value = true;
            const onMediaPause = () => isPlaying.value = false;
            const onMediaEnded = handleChapterEnd;
            const updateCurrentSentenceData = (index) => { playerState.currentIndex = index; };
            const saveSettings = () => { localStorage.setItem(SETTING_KEY, JSON.stringify(settings)); };
            const restoreSettings = () => { const s = JSON.parse(localStorage.getItem(SETTING_KEY) || '{}'); Object.assign(settings, s); };
            const toggleVideoMode = () => { settings.showVideoMode = !settings.showVideoMode; saveSettings(); };
            const toggleFixedSubtitleBar = () => { settings.useFixedSubtitleBar = !settings.useFixedSubtitleBar; saveSettings(); };
            const cyclePlaybackRate = () => { settings.rateIndex = (settings.rateIndex + 1) % playbackRates.length; saveSettings(); if(getActiveMedia()) getActiveMedia().playbackRate = playbackRates[settings.rateIndex]; };
            const cyclePlayMode = () => { settings.playMode = (settings.playMode + 1) % playModes.length; saveSettings(); showToast(playModes[settings.playMode]); };
            const cycleDisplayMode = () => { settings.displayMode = (settings.displayMode + 1) % displayModes.length; revealedMap.value = {}; saveSettings(); };
            const cycleChapterEndMode = () => { settings.chapterEndMode = (settings.chapterEndMode + 1) % chapterEndModes.length; saveSettings(); };
            const cycleTheme = () => { settings.themeIndex = (settings.themeIndex + 1) % themeNames.length; saveSettings(); };
            const cycleFont = () => { settings.fontIndex = (settings.fontIndex + 1) % fonts.length; saveSettings(); };
            const cycleFontSize = () => { settings.fontSizeIndex = (settings.fontSizeIndex + 1) % fontSizes.length; saveSettings(); };
            const toggleReadingMode = () => { settings.readingModeType = (settings.readingModeType + 1) % 3; saveSettings(); showToast(['Âê¨‰π¶', 'ÊªëÂä®', 'ÈòÖËØª'][settings.readingModeType]); };
            const addToVocabulary = () => { if (!currentNoteData.value) { showToast('Êó†Ê≥ïÊî∂Ëóè: Êï∞ÊçÆ‰∏¢Â§±'); return; } const { text, note, sentIdx } = currentNoteData.value; const sent = chapterData.sentences[sentIdx]; if (!db.value) { showToast('Êï∞ÊçÆÂ∫ìËøûÊé•Â§±Ë¥•'); return; } db.value.collection('vocabulary').add({ english: text, chinese: note, bookId: chapterData.bookId, chapterId: chapterData.chapterId, contextEn: sent ? sent.en_segments.map(s=>s.text).join('') : '', contextCn: sent ? sent.cn_text : '', createTime: db.value.serverDate() }).then(() => { showToast('Êî∂ËóèÊàêÂäü'); showPop.value = false; }).catch(err => { console.error('Êî∂ËóèÂ§±Ë¥•:', err); showToast('Êî∂ËóèÂ§±Ë¥•: ÊùÉÈôê‰∏çË∂≥ÊàñÈáçÂ§ç'); }); };
            const saveProgress = (idx) => { const key = `${chapterData.bookId}_${chapterData.chapterId}`; localStorage.setItem(PROGRESS_KEY + '_' + key, idx); };
            const handleContainerTap = (e, index) => { playAt(index, false); };
            const onContainerClick = () => { showPop.value = false; showSettingsPopup.value = false; };
            const toggleSettingsPopup = () => { showSettingsPopup.value = !showSettingsPopup.value; };
            const scrollToCenter = (index) => { nextTick(() => { const el = document.getElementById('sent-' + index); const container = document.querySelector('.content-area'); if (el && container) { const top = el.offsetTop - container.offsetTop - (container.clientHeight / 2) + (el.clientHeight / 2); container.scrollTo({ top: top, behavior: 'smooth' }); } }); };
            const toggleReveal = (index) => { if (maskMode.value || hideAllText.value) { revealedMap.value[index] = !revealedMap.value[index]; } };
            const handleTouchStart = (e) => { /* ... */ }; const handleTouchEnd = (e) => { /* ... */ };
            const onSliderChange = (e) => { const val = e.target.value; const media = getActiveMedia(); if (media && progress.durationSeconds) { const targetTime = (val / 100) * progress.durationSeconds; media.currentTime = targetTime; } isDragging.value = false; };
            const onSliderChanging = () => isDragging.value = true;
            const handleOverlayNoteClick = (item) => { /* ... */ };
            
            return {
                isLoading, toastMsg, watermarkId, settings, chapterData, playerState,
                progress, isPlaying, isDragging, videoPlayer, revealedMap, currentNoteSegments,
                showSettingsPopup, showPop, popover, clickSource, isFullScreen,
                showCN, maskMode, hideAllText,
                themeNames, playbackRates, playModes, displayModes, chapterEndModes, fonts, fontSizes,
                onMediaTimeUpdate, onMediaLoaded, onMediaEnded, onMediaPlay, onMediaPause,
                togglePlay, playPrev, playNext, toggleReadingMode,
                toggleVideoMode, toggleFixedSubtitleBar, cyclePlaybackRate, cyclePlayMode, cycleDisplayMode, cycleChapterEndMode, cycleTheme, cycleFont, cycleFontSize, toggleSettingsPopup,
                handleContainerTap, onContainerClick, showNote, handleOverlayNoteClick, addToVocabulary, toggleReveal,
                handleTouchStart, handleTouchEnd, onScroll, onSliderChange, onSliderChanging
            };
        }
    }).mount('#app');
</script>
</body>
</html>
